---
title: CS50
layout: base
---

# CS50 Notes

## [Lecture 0](https://cs50.harvard.edu/college/2022/spring/notes/0/)
## [Lecture 1](https://cs50.harvard.edu/college/2022/spring/notes/1/)

### Compiling

    make <program_name>

With file ending.


Make can be used to compile most files. Then one can execute them without file ending.

    ./<program_name>

### Basic C syntax

No need to go over this.

## [Lecture 2](https://cs50.harvard.edu/college/2022/spring/notes/2/)

### Some more compiling

Make is essentially calling the language specific compilers. For C clang is called. With clang includes need to be manually added as an argument. Make does this automatically.

Compiling is generally done in multiple steps:
1. Preprocessing:
    - adding in includes and macros
    - removing comments
2. Compiling
    - converts code to assembly
3. Assembling
    - converts assembly to binary, which is machine code and can be run on a CPU.
4. Linking
    - puts compiled includes in the binary code. No need to compile includes multiple times.

### Debugging

Bugs are errors in a program, so that it performs differently than expected. Finding and fixing these errors is called Debugging.

## [Lecture 3](https://cs50.harvard.edu/college/2022/spring/notes/3/)

### Search

Arrays are just lists of entries. Computers can only look at one entry at a time, so search algorithms are needed to look up specific entries.

### Big *O*

Most search algorithms try to achieve the same thing. The main difference is the running time. This is not exactly in seconds but as the complexity of the algorithm.

To do that one uses the big *O* notation, which describes how much time the algorithm takes approximately dependent on the size of the problem. The most common running times are:
- \\(O(n^2)\\)
- \\(O(n \log n)\\)
- \\(O(n)\\)
- \\(O(\log n)\\)
- \\(O(1)\\)

The \\(O\\) describes the upper bound of time steps an algorithm takes. The lower bound is described by \\(\Omega\\), and if the two are the same one uses \\(\Theta\\).

### Different search algorithms

[Here.]({% link _content/search.md %})

### Different sorting algorithms

[Some Sort Algorithms.]({% link _content/sort.md %})

### Recursion

Recursion can be helpful to express logic, for example binary search. One needs to be careful when defining the breaking condition, so not too much memory is used by going too deep.
